ModuleDecl. Module ::= "module" ObjAttr "where";
Toplevel.  Rules ::= [Toplevels];
rules      Toplevels ::= Rule | Module | Import | Pragma | Entity | Knol ;
terminator Toplevels ";";

layout toplevel;
entrypoints Rules;
comment "//" ;
comment "--" ;
comment "/*" "*/" ;
rules Pragma ::= "pragma" CommaList ;
Import. Import ::= "import" ObjAttr ;

rules      RuleDef   ::= RuleNum | RuleID | RuleName
                       | RuleNum   RuleID 
                       | RuleNum            RuleName
                       |           RuleID   RuleName
                       | RuleNum   RuleID   RuleName ;
rules      RuleID    ::= ObjAttr ;
RName.     RuleName  ::= LangStrings ;
RNum.      RuleNum   ::= Integer;

Rule.      Rule      ::= "RULE" RuleDef RuleBody;
RBNoop.    RuleBody  ::= "NOOP";

-- DEEM Potato IS noble WHEN ownersAreNoble
RBis.     RuleBody  ::= "DEEM"  ObjAttr     "IS"  [ObjAttrAnd] WhenPred WhereExpr;
RBare.    RuleBody  ::= "DEEM" [ObjAttrAnd] "ARE" [ObjAttrAnd] WhenPred WhereExpr;

-- DEEM Potato ISA DiscountItem WHEN CurrentDate ~ Weekend
RBisa.    RuleBody  ::= "DEEM"  ObjAttr     "ISA" [ObjAttrAnd] WhenPred WhereExpr;

-- DEEM Potato HAS discount == 20% WHEN CurrentDate WITHIN 1 week OF ExpirationDate
RBhas.    RuleBody  ::= "DEEM"  ObjAttr     "HAS" [ObjAttrAnd] WhenPred WhereExpr;

separator nonempty ObjAttrAnd "AND";
OBAnd.    ObjAttrAnd ::= ObjAttr ;

rules      WhenPred ::= | "WHEN" PredExpr ;

-- ... WHEN  
PEUnify.   PredExpr  ::= UnifyExpr;
PEAnd.     PredExpr  ::= PredExpr "AND" PredExpr;
PEOr.      PredExpr  ::= PredExpr "OR"  PredExpr;
PEME.      PredExpr1 ::= MatchExpr;
PELikely.  PredExpr2 ::= Likelihood PredExpr ;
_.         PredExpr2 ::= "(" PredExpr ")";
coercions PredExpr 2;
-- do we really need to say coercions?
rules      UnifyExpr ::= [UnifyElem] | PlainVal;
rules      VarExpr   ::= ObjAttr | PlainVal;
rules      PlainVal  ::= Numberlike | String
                       | BraceList | JunctionList | ArrayOfBraces
                       | DateTime | DateTime "to" DateTime | Boolean;
rules      UnifyElem ::= ObjAttrElem
                      |  UnifyBracket
                      |  UnifyStar;
separator nonempty UnifyElem ".";
rules      UnifyStar ::= "*" ;
rules      UnifyBracket ::= "[" CommaList "]" ;
ME_OA_JL.  MatchExpr  ::= UnifyExpr "~" JunctionList ;
ME_OA_Bin. MatchExpr  ::= UnifyExpr BinOp UnifyExpr ;
BTrue.     Boolean    ::= TrueBool; -- later, maybe | "yes"
BFalse.    Boolean    ::= FalseBool;

token TrueBool  ["Tt"] ["Rr"] ["Uu"] ["Ee"] ;
token FalseBool ["Ff"] ["Aa"] ["Ll"] ["Ss"] ["Ee"];

-- similar to CLP #=
rules      BinOp      ::= "+" | "-" | "*" | "/" | "<" | ">" | "<=" | ">=" | "==" | "IS" | "ISA" | "ARE";

rules      Numeric    ::= Integer | Double ;
rules      Numberlike ::=        Numeric
                        | "$"    Numeric
                        | CurrID Numeric
                        |        Numeric "%" ;
rules      Likelihood  ::= | "LIKELY" | "UNLIKELY";
JL_And.    JunctionList ::= "["   AndList "]" ;
JL_Or.     JunctionList ::= "["    OrList "]" ;
JL_Xor.    JunctionList ::= "["   XorList "]" ;
JL_Comma.  JunctionList ::= "[" CommaList "]" ;

CommaList.  CommaList ::= [CommaElem];
rules      CommaElem ::= ObjAttr | String;
separator nonempty CommaElem ",";

AndList.   AndList ::= [AndElem];
rules      AndElem ::= ObjAttr | String;
separator nonempty AndElem "&";

OrList.    OrList ::= [OrElem];
rules      OrElem ::= ObjAttr | String;
separator nonempty OrElem "|";

XorList.   XorList ::= [XorElem];
rules      XorElem ::= ObjAttr | String;
separator nonempty XorElem "^";


rules      ObjAttrElem  ::= Ident | UIdent ;            -- Foo

OA_dots.   ObjAttr      ::= [ObjAttrElem];              -- Foo.Bar.Baz
OA_method. ObjAttr      ::= ObjAttr "(" CommaList ")" ; -- Foo.Bar(Baz, Quux)
separator nonempty ObjAttrElem ".";


Entity.    Entity    ::= "ENTITY" ObjAttr
                         GivenLimb
                         EntityDef;

rules      GivenLimb ::= | "GIVEN"  GivenExpr ;
rules      GivenExpr ::=   ObjAttr "HAVING"  PredExpr ;

rules      EntityDef ::= "ISA" ObjAttr WithExpr Asof WhenPred WhereExpr
                       | "HAS"         WithExpr Asof WhenPred WhereExpr;

rules      WithExpr  ::= | "WITH" "{" [WithIn] "}";
rules      WithIn    ::= [BraceElem] | TraceExpr;
separator nonempty WithIn ";";

rules      TraceExpr ::= "TRACE" "{" [LogEvent] "}";
rules      LogEvent ::= Iso8601 ObjAttr ObjAttr ObjAttr BlahBlah ;
separator nonempty LogEvent ";";
separator nonempty Blah "";
rules      BlahBlah ::= [Blah] | ;
rules      Blah     ::= Numberlike | ObjAttr | JunctionList | BraceList;

layout "WITH", "TRACE", "WHERE" ;

rules     WhereExpr ::= | "WHERE" "{" [WhereIn] "}" ;
rules     WhereIn   ::= ObjAttr "ISA" ObjAttr 
                      | ObjAttr "ISA" ObjAttr WithExpr
                      | BraceElem;
separator nonempty WhereIn ";";

rules      UIdentList ::= [UIdentElem];
rules      UIdentElem ::= UIdent;
separator nonempty UIdentElem ".";

token UIdent (upper (letter | digit | '_')*) ;

rules BraceList ::= "{" [BraceElem] "}" ;
rules  BraceElem ::= ObjAttr "=" VarExpr;
separator nonempty BraceElem  "," ;
rules ArrayOfBraces ::= "[" [BraceList] "]";
separator nonempty BraceList "," ;

Knol.       Knol     ::= "KNOL" ObjAttr WithExpr;
Asof.      Asof      ::= "ASOF" DateTime ;
AsofNull.  Asof      ::= ;
rules      DateTime  ::= Iso8601 | "PRESENT" | "NOW" ;
rules      Iso8601   ::= YYYYMMDD | YYYYMMDDTHHMM;

token YYYYMMDD      ( digit digit digit digit '-'? digit digit '-'? digit digit );
token YYYYMMDDTHHMM ( digit digit digit digit '-'? digit digit '-'? digit digit 'T' digit digit digit digit );

-- WHEN X WITHIN Y OF Z
EString.      NormalString ::= String ;
ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= LangID NormalString ;
rules         LangID       ::= ":" [LangLabel] ":";
rules         LangLabel    ::= Ident ;
    separator nonempty LangLabel "," ;

rules         CurrID       ::= ":" CurrLabel ":";
rules         CurrLabel    ::= UIdent ;
