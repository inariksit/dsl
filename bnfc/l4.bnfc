ModuleDecl. Module ::= "module" ObjAttr "where";
Toplevel.  Tops      ::= [Toplevels];
rules      Toplevels ::= Module | Import | Pragma 
                       | Rule | Entity | Scenario;
terminator Toplevels ";";

layout toplevel;
layout "WITH", "TRACE", "WHERE" ;
entrypoints Tops;
comment "//" ;
comment "--" ;
comment "/*" "*/" ;
rules Pragma ::= "pragma" CommaList ;
Import. Import ::= "import" ObjAttr ;

rules      RuleDef   ::= RuleNum | RuleID | RuleName
                       | RuleNum   RuleID 
                       | RuleNum            RuleName
                       |           RuleID   RuleName
                       | RuleNum   RuleID   RuleName ;
rules      RuleID    ::= ObjAttr ;
RName.     RuleName  ::= LangStrings ;
RNum.      RuleNum   ::= Integer;

Rule.      Rule      ::= "RULE" RuleDef RuleBody;
RBNoop.    RuleBody  ::= "NOOP";

RuleDeem.   RuleBody  ::= "DEEM" ObjAttr ObjRelations ;

-- DEEM Potato IS noble WHEN ownersAreNoble
DeemIs.     ObjRelations ::= "IS"  [ObjAttrAnd] WithLimb WhenLimb WhereLimb;

-- DEEM Potato ISA DiscountItem WHEN CurrentDate ~ Weekend
DeemIsa.    ObjRelations ::= "ISA" [ObjAttrAnd] WithLimb WhenLimb WhereLimb;

-- DEEM Potato HAS discount == 20% WHEN CurrentDate WITHIN 1 week OF ExpirationDate
DeemHas.    ObjRelations ::= "HAS" [ObjAttrAnd] WithLimb WhenLimb WhereLimb;

separator nonempty ObjAttrAnd "AND";
OBAnd.    ObjAttrAnd ::= ObjAttr ;

rules      WhenLimb ::= | "WHEN" PredExpr UnlessExpr;

-- ... WHEN  
PEUnify.   PredExpr  ::= UnifyExpr;
PEAnd.     PredExpr  ::= PredExpr "AND" PredExpr;
PEOr.      PredExpr  ::= PredExpr "OR"  PredExpr;
PENot.     PredExpr1 ::=          "NOT" PredExpr;
PEME.      PredExpr2 ::= MatchExpr;
PELikely.  PredExpr3 ::= Likelihood PredExpr ;
PEmethod.  PredExpr4 ::= PredExpr "(" [Assignment] ")" ;
_.         PredExpr5 ::= "(" PredExpr ")";
coercions PredExpr 5;
-- do we really need to say coercions?

rules      UnlessExpr ::= | "UNLESS" PredExpr;
rules      UnifyExpr ::= [UnifyElem] | PlainVal;
rules      VarExpr   ::= ObjAttr | ObjAttr "(" [Assignment] ")" | PlainVal | MathExpr;
rules      PlainVal  ::= Numberlike | String
                       | BraceList | JunctionList | ArrayOfBraces
                       | DateTime | DateTime "to" DateTime | Boolean;
rules      UnifyElem ::= ObjAttrElem
                      |  UnifyBracket
                      |  UnifyStar;
separator nonempty UnifyElem ".";
rules      UnifyStar ::= "*" ;
rules      UnifyBracket ::= "[" CommaList "]" ;
ME_OA_JL.  MatchExpr  ::= UnifyExpr  "~" JunctionList ;
ME_OA_NJL. MatchExpr  ::= UnifyExpr "!~" JunctionList ;
ME_OA_Bin. MatchExpr  ::= UnifyExpr BinOp UnifyExpr ;

rules      MathExpr  ::= Numberlike | ObjAttr
                       | MathExpr "+" MathExpr
                       | MathExpr "-" MathExpr
                       | MathExpr "*" MathExpr
                       | MathExpr "/" MathExpr ;
_.         MathExpr  ::= "(" MathExpr ")" ;

-- similar to CLP #=
rules      BinOp      ::= "+" | "-" | "*" | "/" | "<" | ">" | "<=" | ">=" | "==" | "IS" | "ISA" | "ARE" | "~" | "!~" ;

rules      Numeric    ::= Integer | Double ;
rules      Numberlike ::=        Numeric
                        | "$"    Numeric
                        | CurrID Numeric
                        |        Numeric "%" ;
rules      Likelihood  ::= | "LIKELY" | "UNLIKELY";
JL_And.    JunctionList ::= "["   AndList "]" ;
JL_Or.     JunctionList ::= "["    OrList "]" ;
JL_Xor.    JunctionList ::= "["   XorList "]" ;
JL_Comma.  JunctionList ::= "[" CommaList "]" ;

CommaList.  CommaList ::= [CommaElem];
rules      CommaElem ::= ObjAttr | String;
separator nonempty CommaElem ",";

AndList.   AndList ::= [AndElem];
rules      AndElem ::= ObjAttr | String;
separator nonempty AndElem "&";

OrList.    OrList ::= [OrElem];
rules      OrElem ::= ObjAttr | String;
separator nonempty OrElem "|";

XorList.   XorList ::= [XorElem];
rules      XorElem ::= ObjAttr | String;
separator nonempty XorElem "^";


rules      ObjAttrElem  ::= Ident | UIdent ;            -- Foo

OA_dots.   ObjAttr      ::= [ObjAttrElem];              -- Foo.Bar.Baz
separator nonempty ObjAttrElem ".";


REntity.   Entity ::= "ENTITY" ObjAttr GivenLimb "ISA" [ObjAttrAnd] WithLimb Asof WhenLimb WhereLimb;

rules      GivenLimb ::= | "GIVEN"  GivenExpr ;
rules      GivenExpr ::=   ObjAttr
                         | ObjAttr HavingLimb ;
rules     HavingLimb ::= "HAVING"  PredExpr;

rules      WithLimb  ::= | "WITH" "{" [WithIn] "}";
rules      WithIn    ::= [Assignment] | TraceExpr;
separator nonempty WithIn ";";
rules      TraceExpr ::= "TRACE" "{" [LogEvent] "}";
rules      LogEvent ::= Iso8601 ObjAttr ObjAttr BlahBlah ;
separator nonempty LogEvent ";";
separator Blah "";
rules      BlahBlah ::= | [Blah] ;
rules      Blah     ::= Numberlike | ObjAttr | JunctionList | BraceList;
rules     WhereLimb ::= | "WHERE" "{" [WhereIn] "}" ;
rules     WhereIn   ::= ObjAttr ObjRelations
                      | Assignment;
separator nonempty WhereIn ";";
Asof.      Asof      ::= "ASOF" DateTime ;
AsofNull.  Asof      ::= ;
rules      DateTime  ::= Iso8601 | "PRESENT" | "NOW" ;
rules      Iso8601   ::= YYYYMMDD | YYYYMMDDTHHMM;

token YYYYMMDD      ( digit digit digit digit '-'? digit digit '-'? digit digit );
token YYYYMMDDTHHMM ( digit digit digit digit '-'? digit digit '-'? digit digit 'T' digit digit digit digit );
token UIdent (upper (letter | digit | '_')*) ; -- doesn't seem to work for single character idents though, like P
rules      UIdentList ::= [UIdentElem];
rules      UIdentElem ::= UIdent;
separator nonempty UIdentElem ".";

BTrue.     Boolean    ::= TrueBool; -- later, maybe | "yes"
BFalse.    Boolean    ::= FalseBool;

token TrueBool  ["Tt"] ["Rr"] ["Uu"] ["Ee"] ;
token FalseBool ["Ff"] ["Aa"] ["Ll"] ["Ss"] ["Ee"];
rules BraceList     ::= "{" [Assignment] "}" ;
rules  Assignment   ::= ObjAttr "=" VarExpr;
rules ArrayOfBraces ::= "[" [BraceList] "]";
separator nonempty Assignment  "," ;
separator nonempty BraceList "," ;
RScenario. Scenario ::= "SCENARIO" ObjAttr WithLimb TraceExpr Asof WhereLimb ;
RModal.  RuleBody    ::= GivenLimb PartyLimb DeonticLimb WhenLimb DeadlineLimb HenceLimb WhereLimb ;
rules    PartyLimb   ::= "PARTY" ObjAttr ;
rules    DeonticLimb ::= DeonticExpr ActionLimb;
DEMust.  DeonticExpr ::= "MUST" ;
DEMay.   DeonticExpr ::= "MAY"  ;
DEShant. DeonticExpr ::= "SHANT" ;
rules    ActionLimb  ::= ObjAttr BlahBlah ;
rules    DeadlineLimb ::= | "BEFORE" TemporalExpr ;
rules    TemporalExpr ::= DateTime DurationExpr | ObjAttr DurationExpr ;
rules    DurationExpr ::= | "+" Duration ;
TDYM.    Duration     ::= Integer "years" ;
TDW.     Duration     ::= Integer "weeks" ;
TDD.     Duration     ::= Integer "days" ;
TDDH.    Duration     ::= Integer "days" "and" Integer "hours" ;
DNoHence. HenceLimb    ::= ;
DHence.   HenceLimb    ::= "HENCE" RuleDef ;
DHeLe.    HenceLimb    ::= "HENCE" RuleDef "LEST" RuleDef ;
DLest.    HenceLimb    ::=                 "LEST" RuleDef ;
EString.      NormalString ::= String ;
ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= LangID NormalString ;
rules         LangID       ::= ":" [LangLabel] ":";
rules         LangLabel    ::= Ident ;
    separator nonempty LangLabel "," ;

rules         CurrID       ::= ":" CurrLabel ":";
rules         CurrLabel    ::= UIdent ;
