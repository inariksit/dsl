#+TITLE: The future home of the L4 DSL

Right now, most of the action is over in the [[https://github.com/smucclaw/complaw/][complaw]] repo.

* Draft Language Specification v0.2.0

** By Example

*** A Simple Law

*** A Simple Contract

*** Libraries and Defaults

**** Time

**** Space: "Jurisdiction"


** Formal Verification

How to perform static analysis on the programs.

** Natural Language Generation

How to compile to natural languages.

** 

** How To Try It For Yourself

A web REPL? IDE support?

** How To Contribute

Github issues.

** Introduction

** Tutorials

This section will link to standalone tutorials that work through case studies for common scenarios.

** Compiler Documentation

*** Stages

**** Lexing

handled by BNFC

**** Parsing to Abstract Syntax Tree

handled by BNFC

**** Validation Stage 1

- build a lexical symbol table of defined terms
- Are all defined terms used?
- Identify all undefined terms (which, presumably, would become interview questions in an abductive reasoner)
- distinguish between declared and defined terms

**** Metaprogramming

Any reference to "he" in this document shall be read as "she" where appropriate.

Nothing in this rule shall limit the right to xxx

**** Validation Stage 2

**** Numbering Resolution

**** Cross-Reference Resolution

**** Versioning Resolution

A current rule may refer to an obsolete rule as part of a hypothetical evaluation: /the benefit defined by this rule shall be no lesser than the benefit afforded by any previous version of this rule./

is a clumsy but compact way of saying, evaluate the current rule, evaluate the old rules, and take the max. This requires, in turn, that the old rules be resolvable using the same inputs available to the current rule. If that is not possible, the reasoner needs to raise an error, or ask what to do to handle that situation.


*** Intermediate Representation

So! Thanks to BNFC we have things in Haskell datatypes. That's our abstract representation.

And then we massage those types a bit. We did some validation, verification, inferencing, maybe some rewriting and transformation.

Next we turn those things into concrete outputs.


*** Output Targets

**** Prolog

The transformation looks like this:

- input :: Rule ... Given X ... DEEM X.foo WHEN X.bar AND X.baz
- output :: foo(X) :- bar(X), baz(X).

#+begin_src haskell :tangle ToProlog.hs
  module ToProlog where

  import AbsL
  import Data.List (intercalate)

  class ToProlog a where
    toProlog :: a -> String

  instance ToProlog Rules where
    toProlog (EModule rules) =
      unlines $ toProlog <$> rules

  instance ToProlog Rule where
    toProlog (RuleStanza ruledef rulebody) =
      unlines [ unwords [ "%% ruleDef:",   show ruledef ]
              , unwords [ "%% ruleBody:",  show rulebody ]
              , unwords [ toProlog rulebody ]
              ]

  instance ToProlog RuleBody where
    toProlog RBNoop = "%% NOOP lol"
    toProlog (RBDeem objattrands predexpr) = unlines $
      (\(ObjAttrAnd1 objAttr) -> unwords [ toProlog objAttr
                                         , ":-"
                                         , toProlog predexpr ++ "." ])
      <$> objattrands

  instance ToProlog ObjAttr where 
    toProlog (ObjAttr1 objAttrElems) =
      let outside = last (toProlog <$> objAttrElems)
          inside  = init (toProlog <$> objAttrElems)
      in outside ++ "(" ++ intercalate "." inside ++ ")"

  instance ToProlog ObjAttrElem where 
    toProlog (ObjAttrElemIdent (Ident oaeii)) = oaeii

  instance ToProlog PredExpr where 
    toProlog (PredExprObjAttr oa)  = toProlog oa
    toProlog (PredExpr1 and1 and2) = toProlog and1 ++ ", " ++ toProlog and2

#+end_src

**** Flora-2

**** Python for DocAssemble

**** Javascript because Javascript is everywhere, like bacteria on your skin



** Reference Manual

*** Projects

An L4 Project contains one or more modules.

*** Modules and Structure

An L4 Module is a file.

The /default name/ of the module is derived from its import statement, minus any ~.l4*~ extension.

The following import statements result in the following default module names:

| import                                          | default name |
|-------------------------------------------------+--------------|
| =import "Foo/Bar/Baz.l4"=                       | Foo.Bar.Baz  |
| =import "/usr/local/share/L4/./Foo/Bar/Baz.l4"= | Foo.Bar.Baz  |
| =import "test/./Foo/Bar/Baz.l4"=                | Foo.Bar.Baz  |

The default name is made by 
- deleting any prefix matching the regex ~^.*/\.+/~
- deleting any suffix matching the suffix ~\.l4\w*$~
- converting any directory separators to dots

An L4 Module contains a list of directives and statements.

#+begin_src bnfc :noweb-ref l4rules
EModule.  Rules ::= [Rule];
terminator Rule ";";

layout toplevel;
entrypoints Rules;
#+end_src

C-style and Javascript-style comments are both supported.

#+begin_src bnfc :noweb-ref l4rules
    comment "//" ;
    comment "/*" "*/" ;
#+end_src

*** Directives

**** module

A module can explicitly give itself a name by saying

#+begin_src haskell
module Foo.Bar.Baz where
#+end_src

**** version

**** history

previous versions of this ruleset are accessible where? because this ruleset may refer to previous versions.

**** import



**** numbering

A numbering directive instructs the output engine to reset the autonumbering to a specific value.

*** Statements

An L4 statement is one of the following:

**** A Rule Statement

#+begin_src bnfc :noweb-ref l4rules
  rules      RuleDef   ::= RuleNum | RuleID | RuleName
                         | RuleNum   RuleID 
                         | RuleNum            RuleName
                         |           RuleID   RuleName ;
  RID.       RuleID    ::= Ident ;
  RName.     RuleName  ::= LangStrings ;
  RNum.      RuleNum   ::= Integer;

  RuleStanza.  Rule      ::= "RULE" RuleDef RuleBody;

  RBNoop.    RuleBody  ::= "NOOP";

  -- DEEM Item.isPotato AND Item.isVegetable WHEN ...
  RBDeem.    RuleBody  ::= "DEEM" [ObjAttrAnd] "WHEN" PredExpr;
  separator nonempty ObjAttrAnd "AND";
  ObjAttrAnd1. ObjAttrAnd ::= ObjAttr ;

  -- ... WHEN  
  rules      PredExpr  ::= ObjAttr
                         | MatchExpr
                         | PredExpr "AND" PredExpr
                         | PredExpr "OR"  PredExpr 
                         | "(" PredExpr ")";

  rules      FancyBoolOp ::= PlainBoolOp Likelihood;

  rules      PlainBoolOp ::= "AND" | "OR" ;

  rules      Likelihood  ::= "" | "LIKELY" | "UNLIKELY";

  rules     MatchExpr  ::= ObjAttr "~" JunctionList
                         | "True"
                         | "False" ;

  rules     JunctionList ::= "[" CommaList "]"
                           | "["   AndList "]"
                           | "["    OrList "]"
                           | "["   XorList "]" ;

  rules     CommaList ::= [CommaElem];
  rules     CommaElem ::= ObjAttr;
  separator nonempty CommaElem ",";

  rules     AndList ::= [AndElem];
  rules     AndElem ::= ObjAttr;
  separator nonempty AndElem "&";

  rules     OrList ::= [OrElem];
  rules     OrElem ::= ObjAttr;
  separator nonempty OrElem "|";

  rules     XorList ::= [XorElem];
  rules     XorElem ::= ObjAttr;
  separator nonempty XorElem "|";

  rules      ObjAttrElem  ::= Ident ;                  -- Foo

  rules      ObjAttr      ::= [ObjAttrElem]            -- Foo.Bar.Baz
                          | ObjAttr "(" CommaList ")"  -- Foo.Bar(Baz, Quux)
                          ;
  separator nonempty ObjAttrElem ".";

  rules      KeyVal     ::= ObjAttr ":" ObjAttr
                          | ObjAttr "=" ObjAttr ;
  separator nonempty KeyVal ",";


#+end_src

**** Text Examples

#+begin_src text :tangle test1.l4
  RULE 1 RuleOne NOOP

  RULE 2 
   DEEM Item.isEdiblePotato
    AND Item.isTastyFood
    WHEN Item.isPotato
     AND Item.isEdible

  // the Prolog version of the above is:
  // isEdiblePotato(Item) :- isPotato(Item), isEdible(Item).
  //
  // the Flora-2 version of this would probably rely on the Item having properties
  //

  // 
  // RULE 3 fertilize
  //  GIVEN Item BEING Vegetable               // fertilize ( Item : Vegetable )
  //   DEEM Item.pootato
  //     IS Item.species plus "poo"            // (++ "poo") <$> Item.species
  //                                              because every scalar is really a singleton list
  //                                              so everything is a foreach
  // 


  // Meng seems to be reinventing Haskell
  // let's call it HasSQL, haha

  /* like, for example ...

  append "poo" forEach [Foo, Bar, Baz]

  is equivalent to, in some other languages,

      [Foo, Bar, Baz].map(x=>x+"poo")
  or
      (++ "poo") <$> [foo, bar, baz]

  so we can sneak that in to our language too, just with lots of
  syntactic sugar so the "business developers" don't notice we're doing
  a list comprehension

  ,*/

#+end_src

***** The Jurix Paper

#+begin_src l4 :tangle test2.l4
// from the JURIX paper

   RULE   "Sale Restricted"
   PARTY  P
   SHANT  sell Item
   WHEN   Item.isCabbage
   UNLESS sale.onLegalDate
       OR UNLIKELY P.hasExemption from:DirectorOfAgriculture
          HENCE Rule "Return Policy"
   WHERE
      DEEM Item.isCabbage en:"is a cabbage"
           WHEN Item.faostat ~ "FCL ITEM 0358"
             OR (Item.category      ~ "vegetable"
                 AND Item.species   ~ ["Brassica chinensis", "Brassica oleracea"]
                 AND Item.cultivar !~ "botrytis")
      DEEM sale.onLegalDate en:"on the day of a full moon"
           WHEN sale.date ~ LegalDates
           WHERE LegalDates = EXTERNAL url
                              "https://www.almanac.com/astronomy/moon/full/"
        
    RULE "Return Policy"
   GIVEN sale
   PARTY Buyer
     MAY return Item
  BEFORE sale.date + 3W
   HENCE Rule "Net 3"
   
    RULE "Net 3"
   GIVEN return
   PARTY Seller
    MUST refund Amount
  BEFORE return.date + 3D
   WHERE Amount = return.sale.cash * 90%
#+end_src

**** A Scope Statement

*** Expressions

#+begin_src bnfc :noweb-ref l4expressions
EString.      NormalString ::= String ;
ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= [LangID] ":" NormalString ;
ELangID.      LangID       ::= Ident ;
    separator nonempty LangID "," ;
#+end_src

**** String

A normal string looks ="like this"= and obeys the usual conventions around escaped backslashes, quotes, and newlines.

**** Language String

A language string is a normal string prefixed with a language ID prefix.

**** Language Identifiers

A language ID prefix is one or more Langauge

**** Language Stringset

A Language Stringset is one or more language strings separated by whitespace.

**** Lists

***** Plain Lists

Today's available flavours are: ~[Chocolate, Vanilla, Strawberry]~

***** Conjunctive Lists

The whole situation is a mess.

https://www.lectlaw.com/def/c282.htm says: "There are many cases in law where the conjunctive 'and' is used for the disjunctive 'or' and vice versa."

Not just in law! Let's work through an example. Over dinner. Actually, over dessert.

Suppose it is well known that a [[https://en.wikipedia.org/wiki/Neapolitan_ice_cream]["Neapolitan" ice cream]] must contain all of the following flavours: ~[Chocolate, Vanilla, Strawberry]~

No problem so far. Let's rephrase. Simple symbol manipulation, your basic propositional logic.

#+begin_quote
A "Neapolitan" ice cream must contain Chocolate, Vanilla, *and* Strawberry.
#+end_quote

expands, through distributivity of /must/ over /and/:
- a "Neapolitan" ice cream *must* contain Chocolate *and*
- a "Neapolitan" ice cream *must* contain Vanilla *and*
- a "Neapolitan" ice cream *must* contain Strawberry.

As a lawyer might put it: If any "limb" of the above argument fails, then what's in your ice cream bowl might be tasty, but it's not a valid Neapolitan.

All of this flashes through your mind in a split second when the waiter says: "I'm so sorry. We cannot serve Neapolitan ice cream tonight, because the kitchen doesn't have Chocolate, Vanilla, /and/ Strawberry."

By which we understand:
1. All three flavours are needed to form a Neapolitan.
2. The kitchen lacks at least one of them.
3. Thus, it is false that the kitchen has all of Chocolate, Vanilla, and Strawberry.
4. Therefore it is true that the kitchen does not have all of Chocolate, Vanilla, and Strawberry.

"But," interjects the waiter, seeing the look of disappointment on your face, "we're only out of Strawberry; we do have Chocolate and Vanilla; you can still have ice cream if you want."

This confirms that it is *not* true (as you might initially have feared) that the kitchen is completely out of ice cream. It is *not* true that
- the kitchen does not have Chocolate, *and*
- the kitchen does not have Vanilla, *and*
- the kitchen does not have Strawberry.

Wait a minute. Did we just flip the "or" for an "and"? We certainly did!

What *is* true is this:
- the kitchen does not have Chocolate, *or*
- the kitchen does not have Vanilla, *or*
- the kitchen does not have Strawberry.

This is [[https://en.wikipedia.org/wiki/De_Morgan%27s_laws][De Morgan]] at work. "The negation of a conjunction is the disjunction of the negations".

But wait, it gets worse. You say to the waiter:

"Mmm. Appreciate it, but no thanks. Let's just get a round of coffee, and then the check? We'll go to the ice cream shop next door."

"Fair enough, check coming right up!"

Some minutes later, you stroll next door to the ice cream shop.

"Welcome! You made it just before closing. So, we had a lot of customers today; we still have most of the flavours on the board, but we don't have Chocolate, Vanilla, and Strawberry."

Your brush with the Neapolitan is still fresh in your mind. The restaurant used identical phrasing, but meant a different thing! Fifteen minutes ago, next door, it meant that one of the three flavours was unavailable. Now, here, it means that all three are unavailable.

You can see what might drive people to invent a whole new language, [[https://en.wikipedia.org/wiki/Lojban][Lojban]].

In the ice cream shop, "we don't have Chocolate, Vanilla, and Strawberry" expands to:
- we don't have Chocolate *and*
- we don't have Vanilla *and*
- we don't have Strawberry.

In the restaurant, "we don't have Chocolate, Vanilla, and Strawberry" expands to:
- we don't have Chocolate *or*
- we don't have Vanilla *or*
- we don't have Strawberry.

How crazy is English? Distribution over a list is context-dependent! I guess De Morgan's laws were made to be broken.

***** Disjunctive Lists

Let's up the stakes. If English is nuts, we'll go nuts too.

The allergist says: your food must not contain any of the following ingredients: ~[Peanuts, Walnuts, Almonds]~.

Which is to say, the food must not contain Peanuts, Walnuts, or Almonds.

Or: "the food must not contain Peanuts, Walnuts, and Almonds"?

"Here you go. Don't worry, our Rocky Road doesn't contain peanuts, walnuts, and almonds."

Would you eat it?

***** Disjunctive Or versus Exclusive Or

We've talked about "and" meaning "or".

Don't get me started on [[https://en.wikipedia.org/wiki/Exclusive_or#Exclusive_%22or%22_in_English]["or" meaning "xor"]].

***** What is the total space?

Read chapter 11 of MSCDv4. The remainder of this section attempts to formalize all of the possible variants from that chapter.

***** Is there a better way?

L4 is a formal language. The meanings of expressions are explicitly defined.

****** Ternary Logic In L4: "three-valued Booleans"

Let ~p :: a -> Ternary~, which is to say, ~p~ is a predicate; given an input of type ~a~, it will always return Yes, No, or Neither -- "neither" meaning "unknown", "undefined", "null", or "wat". This is an example of a [[https://en.wikipedia.org/wiki/Three-valued_logic][ternary logic]].

Here's a predicate: "has five toes on each fore paw". Most cats, the predicate returns ~true~. But some cats have [[https://en.wikipedia.org/wiki/Polydactyl_cat][polydactyly]]. It's an unusual condition. You can count the number of polydactyls per thousand, on the fingers of ... uh, let's just say it's a rare condition. For them, the predicate would return ~false~.

But what about an amputee, who has no forelegs? They don't have six toes on each foot. They don't have five toes on each foot. They don't have feet at all.

What is the hair colour of a bald man?

What is the airspeed velocity of an unladen Martian swallow?

On a form, you would write in "N/A" for "Not applicable".

That's why we need ternary logic: sometimes yes, sometimes no, sometimes neither.

Here's another predicate: "tailless". The Manx breed are considered tailless -- they are "rumpies" and "stumpies".

A cat is special if it is polydactyl.

A cat is special if it is tailless.

A cat is valuable if it is both polydactyl and tailless.

I wanted to say "a cat is special if it is polydactyl or tailless", but that brings up "exclusive or" considerations -- some might say "if it is both polydactyl and tailless than it isn't special, because it's obviously valuable instead." They're reading "xor" into the "or", in the context of the next sentence.

It isn't logical, but it's English!

So we spare ourselves all that grief by giving explicit definitions. Watch.

****** Junction Lists

In Haskell, ~Data.List.all~ tests a single predicate against a collection of ~a~ values. You can say: the members of the Polydactyly Society are ~all polydactyl~. "Polydactyl" is the predicate. "The Polydactyly Society" is the collection. ~all polydactyl society~ returns ~True~.

#+begin_src haskell
  polydactyl :: Cat -> Bool
  polydactyl cat = length cat.frontLeft.toes  > 5 ||
                   length cat.frontRight.toes > 5

  society = filter polydactyl allcats
#+end_src

But sometimes you want to test a single value against a collection of predicates. Sometimes you want all the predicates to match.

#+begin_example
kitchen.canMakeNeapolitan = kitchen ~ [ hasChocolate
                                      & hasVanilla
                                      & hasStrawberry ]
#+end_example

Sometimes you want to test if any of the predicates match.

#+begin_example
dish.isDangerous = dish ~ [ hasPeanut     -- (hasPeanut dish) == True
                          | hasWalnut
                          | hasAlmond ]
#+end_example

The machinery for this:

#+begin_src haskell :tangle Preds.hs
module Preds where

  allPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  allPreds preds value = all (flip ($) value) preds

  anyPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  anyPreds preds value = any (flip ($) value) preds

  numPreds ::                [ a -> Bool ] -> a -> Int
  numPreds preds value = length (filter (flip ($) value) preds)

  xorPreds ::                [ a -> Bool ] -> a -> Bool
  xorPreds preds value = 1 == numPreds preds value

#+end_src

In L4, collections of predicates are called "junction lists". The term comes from "conjunctions" and "disjunctions", hence "junctions".

In L4, a *conjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~&~ character, for "and".

In L4, a *disjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~|~ character, for "or".

In L4, an *exclusive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~X~ character, for "exclusive or".

In a junction list of three or more elements, the earlier predicates in the list can be separated by a comma "," or by the same as the final separator.

This makes it easy to write:

#+begin_example
  cats = [ alice
         , bob
         , carol
         , dan
         ]

  special = [ polydactyl
            | tailless 
            ]

  valuable = [ polydactyl
             & tailless 
             ]
#+end_example

Conjunctive lists are syntactic sugar for ~all~.

Disjunctive lists are syntactic sugar for ~any~.

Exclusive lists are syntactic sugar for ~oneOf~.

Lists can nest.

Next we talk about matching.

#+begin_example
  specialCats  = [ polydactyl | tailless ] cats
  valuableCats = [ polydactyl & tailless ] cats

  // note that we do NOT support these alternatives in L4 syntax:
  specialCats  = any [ polydactyl, tailless ] cats
  valuableCats = all [ polydactyl, tailless ] cats

  dish.isDangerous = dish [ hasPeanut
                          , hasWalnut
                          | hasAlmond ]
#+end_example

Space application is overloaded as follows:

| LHS            | RHS              | meaning                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | single value     |                                                 |
| single value   | junction list    | boolean                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | list of values   | filter for values which match the junction list |
| list of values | junction list    | filter for values which match the junction list |
|----------------+------------------+-------------------------------------------------|
| list of values | single predicate |                                                 |

The semantics of a conjunctive list:
#+begin_src haskell :tangle Matchable.hs
  module Matchable where

  -- TODO: make this work!

  class Matchable a where
    match  :: (Eq a, Foldable t) => a -> t a -> Bool

  newtype ConjList a = ConjList [a]
  newtype DisjList a = DisjList [a]

  instance Matchable (ConjList a) where
    match x = all (== x)

  instance Matchable (DisjList a) where
    match x = any (== x)
#+end_src

****** "Any" and "all"

Yay English! What's the difference between

"Any zombies will be shot on sight"

and

"All zombies will be shot on sight"

?

No difference!

This is why it's dangerous to reuse words with a rich existing history -- at some point, people will guess wrong.

First-order logic knows how to deal with this situation. That's why we have \exists and \forall.

*** Metaprogramming

**** patterns

basically, macro expansions and function definitions

#+begin_src l4
  PATTERN myfirstpattern
  WHEREVER RuleMatchExpr // a lens-style pattern match against one or more rules
  TRANSFORM  AliasExpr
  TO         ReplacementExpr
  ...
#+end_src

TODO For example we expand a rule about potatoes to also apply to cabbages, expanding ~item.isPotato~ to ~(item.isPotato OR item.isCabbage)~ in the body of any Horn clause.



*** Comments

The usual:

=/* text within C-style comment blocks is ignored */=

=// text after Javascript-style comment slashes is ignored to end of line=

* Developers Guide

#+begin_src sh
$ stack install pretty-simple

$ fswatch test1.l4 TestL MyTestL.hs | perl -nle 'system("clear; make && ./MyTestL test1.l4")'

$ ghcid --command "stack ghci" MyTestL.hs
#+end_src

* Output

#+begin_src bnfc :noweb yes :tangle l4.bnfc
<<l4rules>>
<<l4expressions>>
#+end_src
