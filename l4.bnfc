ModuleDecl. Module ::= "module" ObjAttr "where";
Toplevel.  Rules ::= [Toplevels];
rules      Toplevels ::= Rule | Module | Import | Pragma | Entity | Knol ;
terminator Toplevels ";";

layout toplevel;
entrypoints Rules;
comment "//" ;
comment "/*" "*/" ;
rules Pragma ::= "pragma" [KeyVal] ;
Import. Import ::= "import" ObjAttr ;
Entity.    Entity    ::= "ENTITY" Ident
                         "ISA"   UIdent
                         Asof
                         "WITH"  [WithKeyVal]

layout "WITH" ;
separator WithKeyVal ";" ;

rules  WithKeyVal ::= ObjAttr "=" JunctionList
                    | ObjAttr "=" BraceList
                    | ObjAttr "=" String
                    | ObjAttr "=" ObjAttr ;

rules BraceList ::= "{" [KeyVal] "}" ;

rules      RuleDef   ::= RuleNum | RuleID | RuleName
                       | RuleNum   RuleID 
                       | RuleNum            RuleName
                       |           RuleID   RuleName ;
RID.       RuleID    ::= Ident ;
RName.     RuleName  ::= LangStrings ;
RNum.      RuleNum   ::= Integer;

RuleStanza.  Rule      ::= "RULE" RuleDef RuleBody;

RBNoop.    RuleBody  ::= "NOOP";

-- DEEM Item.isPotato AND Item.isVegetable WHEN ...
RBDeem.    RuleBody  ::= "DEEM" [ObjAttrAnd] "WHEN" PredExpr;
separator nonempty ObjAttrAnd "AND";
ObjAttrAnd1. ObjAttrAnd ::= ObjAttr ;

-- ... WHEN  
PEOA.      PredExpr  ::= ObjAttr;
PEAnd.     PredExpr  ::= PredExpr "AND" PredExpr;
PEOr.      PredExpr  ::= PredExpr "OR"  PredExpr;
PEME.      PredExpr1 ::= MatchExpr;
_.         PredExpr2 ::= "(" PredExpr ")";
coercions PredExpr 2;
-- do we really need to say coercions?

rules      FancyBoolOp ::= PlainBoolOp Likelihood;

rules      PlainBoolOp ::= "AND" | "OR" ;

rules      Likelihood  ::= "" | "LIKELY" | "UNLIKELY";

-- need more cases -- junctionlists
ME_OA_JL.  MatchExpr  ::= ObjAttr "~" JunctionList ;
ME_True.   MatchExpr  ::= "True";
ME_False.  MatchExpr  ::= "False";

JL_And.    JunctionList ::= "["   AndList "]" ;
JL_Or.     JunctionList ::= "["    OrList "]" ;
JL_Xor.    JunctionList ::= "["   XorList "]" ;
JL_Comma.  JunctionList ::= "[" CommaList "]" ;

-- some work to be done here -- the and, or, xor lists have to have at least 2 elements
-- if there's only one element it's a plain list

CommaList.  CommaList ::= [CommaElem];
rules      CommaElem ::= ObjAttr | String;
separator nonempty CommaElem ",";

AndList.   AndList ::= [AndElem];
rules      AndElem ::= ObjAttr | String;
separator nonempty AndElem "&";

XorList.   XorList ::= [XorElem];
rules      XorElem ::= ObjAttr | String;
separator nonempty XorElem "|";

OrList.    OrList ::= [OrElem];
rules      OrElem ::= ObjAttr | String;
separator nonempty OrElem "|";

rules      ObjAttrElem  ::= Ident ;                     -- Foo

OA_dots.   ObjAttr      ::= [ObjAttrElem];              -- Foo.Bar.Baz
OA_method. ObjAttr      ::= ObjAttr "(" CommaList ")" ; -- Foo.Bar(Baz, Quux)
separator nonempty ObjAttrElem ".";

rules      KeyVal     ::= ObjAttr ":" ObjAttr
                        | ObjAttr "=" ObjAttr ;
separator nonempty KeyVal ",";


EString.      NormalString ::= String ;
ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= [LangID] ":" NormalString ;
ELangID.      LangID       ::= Ident ;
    separator nonempty LangID "," ;
